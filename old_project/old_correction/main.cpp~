#include <iostream>
#include <deque>
#include <algorithm>
#include <SFML/Graphics.hpp>
#include "Graphe.h"
#include "Sommet.h"
#include "Arete.h"
#include "Appli.h"
using namespace std;


const int LARGEUR = 1200;
const int HAUTEUR = 800;


const float MAX_ATTRACTIVE = 100.*3;
const float MAX_REPULSIVE = 20.*3;
const float MAX_DEPLACEMENT = 20.;
const float EDGE_LENGTH = 10.*3;
const float GRAVITE = .01;


void calculerDistances(const Graphe &g, Sommet n, map<Sommet, int> & distance){
    // TODO
}

void calculerDistances(const Graphe &g, Sommet n, map<Sommet, map<Sommet, int> > & distance){
    //TODO
}

void initialiserDessin(Graphe & g, unsigned int largeur, unsigned int hauteur){
    for(Sommet n : g.sommets()){
        Coord c {rand()%(largeur), rand() % (hauteur)};
        g.positionSommet(n, c);
    }
}

void initialiserIntelligementDessin(Graphe & g, unsigned int largeur, unsigned int hauteur){
    // TODO
    for(Sommet n : g.sommets()){
        Coord c {rand()%(largeur), rand() % (hauteur)};
        g.positionSommet(n, c);
    }
}


Coord calculerAttractions(const Graphe &g, Sommet n){
    Coord cn = g.positionSommet(n);
    Coord att;
    for(Sommet u : g.voisins(n)){
        Coord cu = g.positionSommet(u);
        Coord dir = (cu-cn) / (cu-cn).norm();
        float dist = (cu-cn).norm();
        dist *= dist;
        att += dir * dist / (EDGE_LENGTH*EDGE_LENGTH);
    }
    if(att.norm() > MAX_ATTRACTIVE){
        att = att / att.norm();
        att = att * MAX_ATTRACTIVE;
    }
    return att;
}

Coord calculerRepulsions(const Graphe & g, Sommet n){
    Coord cn = g.positionSommet(n);
    Coord rep;
    for(Sommet u : g.sommets()){
        if(u == n) continue;
        Coord cu = g.positionSommet(u);
        Coord dir = cn-cu;
        float dist = dir.norm();
        dir = dir / dist;
        dist *= dist;
        if(dist > 1E-3){
            rep += dir * (EDGE_LENGTH / dist);
        }
    }

    if(rep.norm() > MAX_REPULSIVE){
        rep /= rep.norm();
        rep *= MAX_REPULSIVE;
    }
    return rep;
}

Coord calculerForces(const Graphe &g, Sommet n){
    return calculerRepulsions(g,n) + calculerAttractions(g,n);
}


Coord calculerBarycentre(const Graphe &g){
    Coord barycentre;
    for(Sommet n : g.sommets()){
        barycentre += g.positionSommet(n);
    }
    return barycentre / g.nbSommets();
}

Coord calculerForceGravite(const Graphe &g, Sommet n, const Coord &barycentre){
    return (barycentre - g.positionSommet(n)) * GRAVITE;
}

void deplacer(Graphe &g, Sommet n, Coord deplacement, float max_deplacement){
    if( deplacement.norm() > max_deplacement)
    {
        deplacement /= deplacement.norm();
        deplacement *= max_deplacement;
    }
    g.positionSommet(n, g.positionSommet(n)+deplacement);
}


void dessinerGraphe(Graphe & g, Appli &a){
    // initialisation aléatoire
    initialiserDessin(g, LARGEUR, HAUTEUR);

    float max_deplacement = MAX_DEPLACEMENT;
    // répéter autant de fois qu'il y a de sommets
    unsigned int nb_sommets = 200;//g.nbSommets;
    for(unsigned int i = 0; i < nb_sommets; ++i){
        cout << i << " / " << g.nbSommets() << endl;
        Coord barycentre = calculerBarycentre(g);
        for(Sommet n: g.sommets()){
            Coord deplacement = calculerForces(g,n);
            deplacement = deplacement + calculerForceGravite(g, n, barycentre);

            deplacer(g,n, deplacement, max_deplacement);

        }
        max_deplacement = MAX_DEPLACEMENT * (1.- float(i)/nb_sommets) ;
        if(a.running())
            a.exec();
        else return;
    }
}

int main(int argc, char *argv[])
{
    if (argc != 2){
        cout << "Usage: ./app <graph_file>.txt" << endl;
        return 1;
    }
    srand(time(NULL));

    // chargement et création des graphe et fenetre d'affichage
    string fichier (argv[1]);//"graphe.txt";//"fiat.txt"
    Graphe g;
    if(!g.charger(fichier)){
        cout << "Erreur de chargement de fichier" << endl;
        return 1;
    }

    Appli app {LARGEUR, HAUTEUR};
    app.setGraphe(g);

    cout << "Dessin du graphe..." << flush;
    dessinerGraphe(g, app);
    cout << "fini" << endl;

    // pour ne pas fermer la fenêtre après le dessin
    while(app.running())
        app.exec();

    return 0;
}

